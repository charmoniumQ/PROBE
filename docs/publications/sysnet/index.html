<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8"/>
        <title>Creating a dataflow graph on files and processes</title>
        <link
            crossorigin="anonymous"
            href="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.3.0/reset.min.css"
            integrity="sha512-Mjxkx+r7O/OLQeKeIBCQ2yspG1P5muhAtv/J+p2/aPnSenciZWm5Wlnt+NOUNA4SHbnBIE/R2ic0ZBiCXdQNUg=="
            referrerpolicy="no-referrer"
            rel="stylesheet"/>
        <link
            crossorigin="anonymous"
            href="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.3.0/reveal.min.css"
            integrity="sha512-e3dnmFe5hH2bJx1MvUU3PFToGVQ2xykp/VGERCkuh4lTGMJ5QuxKFRIwix8DfnfkavwJiL6rehb9e1d6mFLwlg=="
            referrerpolicy="no-referrer"
            rel="stylesheet"/>
        <link
            crossorigin="anonymous"
            href="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.3.0/theme/black.min.css"
            integrity="sha512-DKeDMgkMDBNgY3g8T6H6Ft5cB7St0LOh5d69BvETIcTrP0E3d3KhANTMs5QOTMnenXy6JVKz/tENmffCLeXPiQ=="
            referrerpolicy="no-referrer"
            rel="stylesheet"/>
    </head>
    <body>
        <div class="reveal">
            <div class="slides">
                <section>
                    <h1>Creating a dataflow graph on files and processes</h1>
                </section>
                <section>
                    <h2>Takeaways</h2>
                    <ol>
                        <li>Tracing provenance for computational expreiments is <i>important</i>.</li>
                        <li>PROBE collects provenance efficiently.</li> <!--TODO-->
                        <li>More research on the exported dataflow graphs is possible.</li>
                    </ol>
                    <div class="qrcode-link" data-caption="PROBE" data-encoded="https://github.com/charmoniumQ/PROBE">
                    </div>
                </section>
                <section>
                    <h2>What is provenance?</h2>
                    <p>
                        <b>Provenance</b> of a file is:
                    </p><ol>
                        <li>the process that created that file,</li>
                        <li>the files used by that process, and</li>
                        <li>the provenance of those files.</li>
                    </ol>
                </section>
                <section>
                    <h2>Why useful?</h2>
                    <ul>
                        <li>Convert to container <i>especially for non computer scientists</i></li>
                        <li>Incremental re-computation</li>
                    </ul>
                </section>
                <section>
                    <h2>How to capture?</h2>
                    <ul>
                        <li>Modify kernel</li>
                        <li>Use hooks, bpf or Linux Security Module</li>
                        <li>Use <code>ptrace</code></li>
                        <li>Use <code>LD_PRELOAD</code></li>
                    </ul>
                </section>
                <section>
                    <h2>PROBE</h2>
                    <p><code>probe record CMD...</code> runs <code>CMD...</code> with <code>LD_PRELOAD</code>.</p>
                    <div class="qrcode-link" data-caption="PROBE" data-encoded="https://github.com/charmoniumQ/PROBE">
                    </div>
                </section>
                <section>
                    <h2>Interposition</h2>
                    <pre class="strip-ws"><code>
                        int open(const char* path, int flags) {
                            ret = real_open(path, flags);

                            return ret;
                        }
                    </code></pre>
                </section>
                <section>
                    <h2>Interposition</h2>
                    <pre class="strip-ws"><code>
                        int open(const char* path, int flags) {
                            if (COPY_FILES_ENABLED &amp;&amp; flags == O_TRUNC &amp;&amp; is_used(path)) {
                                save_copy(path);
                            }

                            ret = real_open(path, flags);

                            return ret;
                        }
                    </code></pre>
                </section>
                <section>
                    <h2>Interposition</h2>
                    <pre class="strip-ws"><code>
                        int open(const char* path, int flags) {
                            // ...

                            append_to_thread_local_mmapped_log({
                                .type = open,
                                .flags = flags,
                                .path = path,
                                .ret = ret,
                            });

                            return ret;
                        }
                    </code></pre>
                </section>
                <section>
                    <p>At the end of execution, each thread has a list of "provenance" operations.</p>
                    <p>Rather than capture every <code>read</code> and <code>write</code>, we capture only the <code>open</code> and <code>close</code>.</p>
                    <p>Multiple processes, multiple threads.</p>
                    <p>How to create dataflow graph for incremental computation?</p>
                </section>
                <section>
                    <h2>HB and DFG</h2>
                    <p>Happens-before := program-order union synchronization-order</p>
                    <p>Synchronization order := {forks, joins, lock accesses}</p>
                    <!-- TODO: figure -->
                    <p>Data <i>cannot</i> flow from A to B, if B happens-before A.</p>
                    <p>Otherwise, data <i>may</i> flow (conservatively sound).</p>
                    <p>Incomplete due to ignorance and actualities</p>
                </section>
                <section>
                    <h2>Races</h2>
                    <p>Are races (W simultaneous to R|W) possible?</p>
                    <p>Yes</p>
                    <p>Happens frequently, due to pipes shell (<code>a | b</code>)!</p>
                </section>
                <section>
                    <pre class="graphviz"><code>
                        digraph {
                            "pipe()\n[/* read */ p0, /* write */ p1]" -> fork0 -> fork1 -> wait0 -> wait1;
                            fork0 -> "dup(p0 → stdin)" -> "close(p1)"  -> "exec(a)" -> wait0;
                            fork1 -> "dup(p1 → stdout)" -> "close(p0)" -> "exec(b)" -> wait1;
                        }
                    </code></pre>
                </section>
                <section>
                    <p>Pick a sample schedule (topological ordering) of HB-graph?</p>
                    <p>Consider the following HB graph</p>
                    <pre class="graphviz"><code>
                        digraph {
                            1 [label="1: read(A)"];
                            2 [label="2: write(B)"];
                            3 [label="1: read(B)"];
                            4 [label="2: write(A)"];
                            1 -> 2 [label="hb"];
                            3 -> 4 [label="hb"];
                        }
                    </code></pre>
                    <pre class="graphviz"><code>
                        digraph {
                            1 [label="1: read(A)"];
                            2 [label="2: write(B)"];
                            3 [label="1: read(B)"];
                            4 [label="2: write(A)"];
                            1 -> 2 [style="invis"];
                            3 -> 4 [style="invis"];
                            {rank=same; 1; 3;}
                            {rank=same; 2; 4;}
                            4 -> 1 [label="dfg"];
                            3 -> 2 [label="dfg"];
                        }
                    </code></pre>
                </section>
                <section>
                    <h2>HB intervals</h2>
                    <p><i>Interval</i> := (set of upper bounds, set of lower bounds), contains all the nodes in between.</p>
                    <p>Happens-before for intervals A and B := For every node in the LB of A, that node happens-before some node in the UB of B.</p>
                    <p>Many ways that happens-before can be violated; one node of A may happen-after one node of B, one node of A may be incomparable to any node of B, examples <!--TODO--></p>
                    <p>None of it matters</p>
                </section>
                <section>
                    <h2>HB intervals...</h2>
                    <p>For each file, identify <i>interval</i> in which the file may be accessed</p>
                    <p>Put intervals in DAG</p>
                    <p>Compute transitive reduction</p>
                    <p>For each read, find the latest preceeding writes on each branch (stable version) and all simultaneous write (transient versions).</p>
                    <p>Mutating writes have similar representation.</p>
                </section>
                <section>
                    <h2>Reachability algorithms</h2>
                    <p>Contains many happens-before queries.</p>
                    <p>Naive, O(1) init, O(V + E) per query.</p>
                    <p>Note: O(V) queries, V ≤ E ≤ 2V, and V = O(10^5)</p>
                    <p>Floyd-Warshall, O(V^3) init, O(1) per query.</p>
                    <p>V topo sorts, O(V(V + E)) init, O(1) per query.</p>
                    <p>Dual-labeling O(V + E + NTE) init, O(1) per query.</p>
                </section>
                <section>
                    <h2>Ambiguities</h2>
                    <p>Still creates ambiguities, due to reuse of FDs</p>
                    <p>TODO: Confirm with <code>mtime</code></p>
                    <p>TODO: Open-numbering</p>
                    <p>TODO: Bloom-filter on writes</p>
                </section>
                <section>
                    <h2>Interoperability</h2>
                    <p>Exports semantic web triples using W3C PROV.</p>
                    <p>File was-created-by process, etc.</p>
                </section>
                <section>
                    <h2>Future work</h2>
                    <ul>
                        <li>Performance analysis</li>
                        <li>ML trustworthiness</li>
                        <li>Intercept network transactions</li>
                        <li>Semantic web integration</li>
                    </ul>
                </section>
            </div>
        </div>
        <script
            crossorigin="anonymous"
            integrity="sha512-lRYVCjdH7dCPCzqLL6eBn78p6WGK5pZxgYBgzTQfWlfX7yiZFLt/qHOMSETHUIz2aZIU/KbjwYHiMsmrcVgJnA=="
            referrerpolicy="no-referrer"
            src="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/5.2.1/reveal.min.js"
        ></script>
       <script type="text/javascript">
         /*<![CDATA[*/
         Reveal.initialize({
             "hash": true,
             "slideNumber": "c/t",
             "transition": "none",
         });
         /*]]*/
        </script>
        <script
            crossorigin="anonymous"
            integrity="sha512-CNgIRecGo7nphbeZ04Sc13ka07paqdeTu0WR1IM4kNcpmBAUSHSQX0FslNhTDadL4O5SAGapGt4FodqL8My0mA=="
            referrerpolicy="no-referrer"
            src="https://cdnjs.cloudflare.com/ajax/libs/qrcodejs/1.0.0/qrcode.min.js"
        ></script>
       <script type="text/javascript">
         /*<![CDATA[*/
         function stripWs(element) {
             Array.from(element.childNodes).forEach((node) => {
                 switch (node.nodeType) {
                     case Node.TEXT_NODE: {
                         let counter = 0;
                         for (const char of node.textContent) {
                             let shouldExit  = false;
                             switch (char) {
                                 case "\n":
                                     counter = 0;
                                     break;
                                 case " ":
                                     counter++;
                                     break;
                                 default:
                                     shouldExit = true;
                             }
                             if (shouldExit) {
                                 break;
                             }
                         }
                         node.textContent = node.textContent.split("\n").map((line) => {
                             if (line.substring(0, counter).match(/ */)) {
                                 return line.substring(counter);
                             } else {
                                 line;
                             }
                         }).join("\n");
                         break;
                     }
                     case Node.ELEMENT_NODE:
                         stripWs(node);
                         break;
                 }
             })
         }
         Array.from(
             document.getElementsByClassName("strip-ws")
         ).forEach(stripWs);
         /*]]*/
        </script>
        <script type="text/javascript">
         /*<![CDATA[*/
         Array.from(document.getElementsByClassName("qrcode-link")).forEach((container) => {
             const a = document.createElement("a");
             const figure = document.createElement("figure");
             const figCaption = document.createElement("figcaption");

             container.appendChild(a);
             a.appendChild(figure);
             figure.appendChild(figCaption);

             a.href = container.dataset.encoded;
             figCaption.textContent = container.dataset.caption;
             new QRCode(figure, {
	             text: container.dataset.encoded,
             });
         });
         /*]]*/
        </script>
        <script>
         Array.from(
             document.getElementsByTagName("section")
         ).forEach((section) => {
             let first = true;
             Array.from(section.children).forEach((child) => {
                 console.log(child.tagName);
                 if (child.tagName.startsWith("H")) {
                     console.log(child);
                 } else if (child.tagName == "ol" || child.tagName == "ul") {
                     Array.from(child.children).forEach((grandchild) => {
                         if (!first) {
                             grandchild.classList.add("fragment");
                         }
                         first = false;
                     });
                 } else {
                     if (!first) {
                         child.classList.add("fragment")
                     }
                     first = false;
                 }
             });
         });
        </script>
    </body>
</html>
