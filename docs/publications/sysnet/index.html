<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8"/>
        <title>Creating a dataflow graph on files and processes</title>
        <link
            crossorigin="anonymous"
            href="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.3.0/reset.min.css"
            integrity="sha512-Mjxkx+r7O/OLQeKeIBCQ2yspG1P5muhAtv/J+p2/aPnSenciZWm5Wlnt+NOUNA4SHbnBIE/R2ic0ZBiCXdQNUg=="
            referrerpolicy="no-referrer"
            rel="stylesheet"/>
        <link
            crossorigin="anonymous"
            href="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.3.0/reveal.min.css"
            integrity="sha512-e3dnmFe5hH2bJx1MvUU3PFToGVQ2xykp/VGERCkuh4lTGMJ5QuxKFRIwix8DfnfkavwJiL6rehb9e1d6mFLwlg=="
            referrerpolicy="no-referrer"
            rel="stylesheet"/>
        <link
            crossorigin="anonymous"
            href="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.3.0/theme/black.min.css"
            integrity="sha512-DKeDMgkMDBNgY3g8T6H6Ft5cB7St0LOh5d69BvETIcTrP0E3d3KhANTMs5QOTMnenXy6JVKz/tENmffCLeXPiQ=="
            referrerpolicy="no-referrer"
            rel="stylesheet"/>
    </head>
    <body>
        <div class="reveal">
            <div class="slides">
                <section>
                    <section>
                        <h1>Creating a dataflow graph on files and processes</h1>
                    </section>
                    <section>
                        <div id="toc"></div>
                    </section>
                </section>
                <section data-title="Motivating problem">
                    <section>
                        <h2>Problem</h2>
                        <p>Scientific data analysis</p>
                        <p>Non-scientists</p>
                        <p>Pile of scripts</p>
                        <p>No time to write documentation</p>
                    </section>
                    <section>
                        <h2>Reproducibility</h2>
                        <p>What to run?</p>
                        <p>Doesn't know all relevant data files</p>
                        <p>May not know about/have time for Docker, Conda</p>
                        <p>Not addressing scheduling; addressing file completeness</p>
                    </section>
                    <section>
                        <h2>Need dataflow graph (DFG) of files/processes</h2>
                        <p>To reproduce <code>plots.png</code>, run <code>script.py --args</code>, needs <code>data.csv</code></p>
                        <p>Pack needed files (data, scripts, executables) into container</p>
                    </section>
                    <section>
                        <pre class="graphviz"><code>
                            strict digraph G {
                                utilsc [shape="oval" label="utils.c"];
                                utilso [shape="oval" label="utils.o"];
                                mainc [shape="oval" label="main.c"];
                                maino [shape="oval" label="main.o"];
                                main [shape="oval" label="main"];
                                datacsv [shape="oval" label="data.csv"];
                                fig1png [shape="oval" label="fig1.png"];
                            
                                compile_utils [shape="rect" label="gcc -c -o utils.o utils.c"];
                                compile_main [shape="rect" label="gcc -c -o main.o main.c"];
                                link [shape="rect" label="gcc main.o utils.o -o main"];
                                runmain [shape="rect" label="./main -n data.csv fig1.png"];
                                curl [shape="rect" label="curl http://example.com/data"];
                            
                                utilsc -> compile_utils -> utilso;
                                mainc -> compile_main -> maino;
                                {utilso maino} -> link -> main;
                                curl -> datacsv;
                                {main datacsv} -> runmain -> fig1png;
                            }
                        </code></pre>
                    </section>
                    <section>
                        <h2>OS knows the way!</h2>
                    </section>
                    <section>
                        <h2>Other applications of DFG</h2>
                        <p>Incremental computation</p>
                        <p>Comprehensibility</p>
                        <p>Parallelization</p>
                    </section>
                </section>

                <section data-title="Overview of PROBE">
                    <section>
                        <h2>Overview of PROBE</h2>
                        <ol>
                            <li>Button press in R Studio</li>
                            <li><code>probe record &lt;CMD&gt;...</code></li>
                            <li>Button press in R Studio</li>
                            <li><code>probe export container &lt;CONTAINER-IMG&gt;</code></li>
                            <li><code>probe export makefile</code></li>
                        </ol>
                    </section>
                    <section>
                        <h2>Technical details</h2>
                        <ol>
                            <li>Library interposition</li>
                            <li>captures file open/close and process fork/join</li>
                            <li>Each thread of each process has local logs of events</li>
                            <li>"Stitch" into DFG</li>
                        </ol>
                    </section>
                </section>

                <section data-title="Problem characterization" data-subtitle="happens-before">
                    <section>
                        <h2>Technical problem</h2>
                        <p>How to stitch thread-local logs into DFG?</p>
                        <p>Don't have every read/write, just open/close with mode (R, W, RW)</p>
                    </section>
                    <section>
                        <h2>Predecessors in prior work</h2>
                        <ul>
                            <li>Distributed systems often assume message passing (vector clocks) not shared memory
                                <ul>
                                    <li>Could use POSIX extended attributes?</li>
                                    <li>xattrs have TOCTTOU</li>
                                    <li>xattrs don't allow mixed authorship</li>
                                </ul>
                            </li>
                            <li>Dynamic bin. analysis traces every read/write
                                <ul>
                                    <li>Tracing open/close is more faster than read/write</li>
                                    <li>But tracing read/write is easier to analyze</li>
                                </ul>
                            </li>
                        </ul>
                    </section>
                    <section>
                        <h2>Elements of prior work</h2>
                        <p>Events \(\events\), files \(\files\)</p>
                        <p>Some events operate on files, \(\filefn: \events \to \files \cup \{ \bot\}\)</p>
                        <p>Program order \(\programorder := \) thread-local log</p>
                        <p>Synchronization order \(\syncorder := \) fork/joins threads/processes</p>
                        <p>Happens-before \(\hb := \transitiveclosure{\programorder | \syncorder}\)</p>
                    </section>
                    <section>
                        <h2>Elements of prior work</h2>
                        <p>\(a\) dominates \(b\) in a set \(C\) iff \(a\) is a "more recent" predecessor than any predecessor in \(c\).</p>
                        <p>\(a \hbdom{C} b ~ := ~ a \hb b \wedge \underset{c \in C}{\forall} c \hb b \implies a \hb b\)</p>
                    </section>
                    <section>
                        <h2>Elements of prior work</h2>
                        <p>\(a \simultaneous b := a \nhb b \wedge b \nhb a\) </p>
                        <p>Read events, \(\readevents\), write events \(\writeevents\)</p>
                        <p>File race := write simultaneous to another access to the same resource, \(a \in \writeevents \wedge a \simultaneous b \wedge \filefn(a) = \filefn(b)\)</p>
                        <p>Write is immediately visible (<a href="https://doi.org/10.1109/TPDS.2024.3391058">Wang et al. 2025</a>)</p>
                    </section>
                    <section>
                        <h2>Further characterization</h2>
                        <p>DFG := directed graph on files and process-states</p>
                        <p>Connect up all \(w \hb r\) unless \(r \hb w\)</p>
                        <p>Sound but not complete</p>
                    </section>
                    <section>
                        <h2>Are races possible? Are they common?</h2>
                        <p>Happens frequently! due to pipes in shell (<code>a | b</code>)</p>
                        <p>Moreover, one open may be correspond to multiple closes, after <code>fork()</code></p>
                    </section>
                    <section>
                        <!--TODO: Fix rank in below graph-->
                        <pre class="graphviz"><code>
                            digraph {
                                pipe [label="pipe()\n⇨ [fd_read, fd_write]"];
                                fork0 [label="fork()", color="purple"];
                                fork1 [label="fork()", color="purple"];
                                wait0 [label="wait()", color="purple"];
                                wait1 [label="wait()", color="purple"];
                                dup_in [label="dup(fd_read → stdin)", color="purple"];
                                dup_out [label="dup(fd_write → stdout)", color="purple"];
                                close_write [label="close(fd_write)", color="blue"];
                                close_read [label="close(fd_read)", color="red"];
                                exec_a [label="exec(a)", color="blue"];
                                exec_b [label="exec(b)", color="red"];

                                subgraph cluster_0 {
                                    label="bash";
                                    pipe -> fork0 -> fork1 -> wait0 -> wait1;
                                }

                                fork0 -> dup_in;
                                exec_a -> wait0;
                                subgraph cluster_1 {
                                    label="a";
                                    dup_in -> close_write  -> exec_a;
                                }

                                fork1 -> dup_out;
                                exec_b -> wait1;
                                subgraph cluster_2 {
                                    label="b";
                                    dup_out -> close_read -> exec_b;
                                }
                            }
                        </code></pre>
                    </section>
                </section>

                <section data-title="Solution" data-subtitle="Intervals of HB">
                    <section>
                        <h2>Solution</h2>
                        <p>Interested in alternative approaches</p>
                        <p>Interested in related prior work</p>
                    </section>
                    <section>
                        <h2>HB Interval</h2>
                        <p>Interval := set of upper and lower bounds, containing all the nodes in between</p>
                        <p>\(\intervals \subseteq \powerset{\events} \times \powerset{\events}\)</p>
                        <p>\(I_a \hb I_b := \underset{a \in \max I_a}{\forall} ~ \underset{b \in \min I_b}{\exists} a \hb b\)</p>
                        <p>"Many" ways that one interval may fail to happen before another, but they don't matter.</p>
                    </section>
                    <section>
                        <h2>Algorithm for files</h2>
                        <pre class="strip-ws"><code>
                            for file in trace:
                                for \(I_a\) that accesses that file:
                                    For write intervals \(I_w\) in the previously dominating set of writes:
                                        Add \(\dfg{\min I_w}{\max I_a}\)
                                    For write intervals \(I_w \simultaneous I_a\):
                                        implicit_communication(\(I_w\), \(I_a\))
                        </code></pre>
                    </section>
                    <section>
                        <h2>Implicit communication</h2>
                        <p>Every event can DFG to every other \(\simultaneous\) event in the same process</p>
                        <p>Only need the last and the first</p>
                        <pre class="strip-ws"><code>
                            for \(a \in I_a\):
                                for \(b \in I_b, b \simultaneous a\):
                                    Add \(\dfg{a}{b}\)
                        </code></pre>
                    </section>
                    <section>
                        <h2>Reachability algorithms</h2>
                        <p>Contains many happens-before queries.</p>
                        <p>Naive, O(1) init, O(V + E) per query.</p>
                        <p>Note: O(V) queries, V ≤ E ≤ 2V, and V = O(10^5)</p>
                        <p>Floyd-Warshall, O(V^3) init, O(1) per query.</p>
                        <p>V topo sorts, O(V(V + E)) init, O(1) per query.</p>
                        <p>Dual-labeling O(V + E + NTE) init, O(1) per query.</p>
                    </section>


                <!-- <section>
                     <h2>HB intervals</h2>
                     <p><i>Interval</i> := (set of upper bounds, set of lower bounds), contains all the nodes in between.</p>
                     <p>Happens-before for intervals A and B := For every node in the LB of A, that node happens-before some node in the UB of B.</p>
                     <p>Many ways that happens-before can be violated; one node of A may happen-after one node of B, one node of A may be incomparable to any node of B, examples <!--TODO--></p>
                        <!-- <p>None of it matters</p>
                             </section>
                             <section>
                             <h2>HB intervals...</h2>
                             <p>For each file, identify <i>interval</i> in which the file may be accessed</p>
                             <p>Put intervals in DAG</p>
                             <p>Compute transitive reduction</p>
                             <p>For each read, find the latest preceeding writes on each branch (stable version) and all simultaneous write (transient versions).</p>
                             <p>Mutating writes have similar representation.</p>
                             </section> -->
                </section>

                <section data-title="Future work">
                    <section>
                        <h2>Ambiguities</h2>
                        <p>Still creates ambiguities, due to reuse of FDs</p>
                        <p>TODO: Confirm with <code>mtime</code></p>
                        <p>TODO: Open-numbering</p>
                        <p>TODO: Bloom-filter on writes</p>
                    </section>
                    <section>
                        <h2>Interoperability</h2>
                        <p>Exports semantic web triples using W3C PROV.</p>
                        <p>File was-created-by process, etc.</p>
                    </section>
                    <section>
                        <h2>Future work</h2>
                        <ul>
                            <li>Performance analysis</li>
                            <li>ML trustworthiness</li>
                            <li>Intercept network transactions</li>
                            <li>Semantic web integration</li>
                        </ul>
                    </section>
                </section>

                <section data-title="Backup slides" data-subtitle="provenance, capturing">
                    <section>
                        <h2>Backup slides</h2>
                    </section>
                    <section>
                        <h2>What is provenance?</h2>
                        <p>
                            <b>Provenance</b> of a file is:
                        </p><ol>
                            <li>the process that created that file,</li>
                            <li>the files used by that process, and</li>
                            <li>the provenance of those files.</li>
                        </ol>
                    </section>
                    <section>
                        <h2>How to capture?</h2>
                        <ul>
                            <li>Modify kernel</li>
                            <li>Use hooks, bpf or Linux Security Module</li>
                            <li>Use <code>ptrace</code></li>
                            <li>Use <code>LD_PRELOAD</code></li>
                        </ul>
                    </section>


                    <section data-visibility="hidden">
                         <h2>Wrong solution</h2>
                         <p>Pick a sample schedule (topological ordering) of HB-graph?</p>
                         <p>Consider the following HB graph</p>
                         <pre class="graphviz"><code>
                            digraph {
                                1 [label="1: read(A)"];
                                2 [label="2: write(B)"];
                                3 [label="1: read(B)"];
                                4 [label="2: write(A)"];
                                1 -> 2 [label="HB"];
                                3 -> 4 [label="HB"];
                            }
                         </code></pre>
                         <pre class="graphviz"><code>
                            digraph {
                                1 [label="1: read(A)"];
                                2 [label="2: write(B)"];
                                3 [label="1: read(B)"];
                                4 [label="2: write(A)"];
                                1 -> 2 [style="invis"];
                                3 -> 4 [style="invis"];
                                {rank=same; 1; 3;}
                                {rank=same; 2; 4;}
                                4 -> 1 [label="dfg"];
                                2 -> 3 [label="dfg"];
                            }
                         </code></pre>
                    </section>
                </section>
        </div>
        <script
            crossorigin="anonymous"
            integrity="sha512-lRYVCjdH7dCPCzqLL6eBn78p6WGK5pZxgYBgzTQfWlfX7yiZFLt/qHOMSETHUIz2aZIU/KbjwYHiMsmrcVgJnA=="
            referrerpolicy="no-referrer"
            src="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/5.2.1/reveal.min.js"
        ></script>
        <script type="text/javascript">
         /*<![CDATA[*/
         Reveal.initialize({
             "hash": true,
             "slideNumber": "c/t",
             "transition": "none",
         });
         /*]]*/
        </script>
        <script
            crossorigin="anonymous"
            integrity="sha512-CNgIRecGo7nphbeZ04Sc13ka07paqdeTu0WR1IM4kNcpmBAUSHSQX0FslNhTDadL4O5SAGapGt4FodqL8My0mA=="
            referrerpolicy="no-referrer"
            src="https://cdnjs.cloudflare.com/ajax/libs/qrcodejs/1.0.0/qrcode.min.js"
        ></script>
        <script type="text/javascript">
         /*<![CDATA[*/
         function stripWs(element) {
             Array.from(element.childNodes).forEach((node) => {
                 switch (node.nodeType) {
                     case Node.TEXT_NODE: {
                         let counter = 0;
                         for (const char of node.textContent) {
                             let shouldExit  = false;
                             switch (char) {
                                 case "\n":
                                     counter = 0;
                                     break;
                                 case " ":
                                     counter++;
                                     break;
                                 default:
                                     shouldExit = true;
                             }
                             if (shouldExit) {
                                 break;
                             }
                         }
                         node.textContent = node.textContent.split("\n").map((line) => {
                             if (line.substring(0, counter).match(/ */)) {
                                 return line.substring(counter);
                             } else {
                                 line;
                             }
                         }).join("\n");
                         break;
                     }
                     case Node.ELEMENT_NODE:
                         stripWs(node);
                         break;
                 }
             })
         }
         Array.from(
             document.getElementsByClassName("strip-ws")
         ).forEach(stripWs);
         /*]]*/
        </script>
        <script type="text/javascript">
         /*<![CDATA[*/
         Array.from(document.getElementsByClassName("qrcode-link")).forEach((container) => {
             const a = document.createElement("a");
             const figure = document.createElement("figure");
             const figCaption = document.createElement("figcaption");

             container.appendChild(a);
             a.appendChild(figure);
             figure.appendChild(figCaption);

             a.href = container.dataset.encoded;
             figCaption.textContent = container.dataset.caption;
             new QRCode(figure, {
	             text: container.dataset.encoded,
             });
         });
         /*]]*/
        </script>
        <script>
         /*<![CDATA[*/
         // Array.from(
         //     document.getElementsByTagName("section")
         // ).forEach((section) => {
         //     let first = true;
         //     Array.from(section.children).forEach((child) => {
         //         console.log(child.tagName);
         //         if (child.tagName.startsWith("H")) {
         //             console.log(child);
         //         } else if (child.tagName == "ol" || child.tagName == "ul") {
         //             Array.from(child.children).forEach((grandchild) => {
         //                 if (!first) {
         //                     grandchild.classList.add("fragment");
         //                 }
         //                 first = false;
         //             });
         //         } else {
         //             if (!first) {
         //                 child.classList.add("fragment")
         //             }
         //             first = false;
         //         }
         //     });
         // });
         /*]]*/
        </script>
        <script>
         /*<![CDATA[<*/
         MathJax = {
             tex: {
                 macros: {
                     events: "\\mathbb{E}",
                     programorder: "\\overset{P}{\\leq}",
                     syncorder: "\\overset{S}{\\leq}",
                     hb: "\\overset{HB}{\\leq}",
                     nhb: "\\overset{HB}{\\not\\leq}",
                     transitiveclosure: ["(#1)^*", 1],
                     simultaneous: "\\overset{HB}{\\sim}",
                     readevents: "r\\mathbb{E}",
                     writeevents: "w\\mathbb{E}",
                     dfg: ["#1 \\overset{DFG}{\\to} #2", 2],
                     xor: "\\textrm{xor}",
                     powerset: ["2^{#1}", 1],
                     intervals: "\\mathbb I",
                     hbdom: ["\\underset{#1}{\\overset{HB}{\\underline{\\ll}}}", 1],
                     files: "\\mathbb F",
                     processes: "\\mathbb P",
                     filefn: "\\mathrm{file}",
                 },
             },
         };
         /*]]*/
        </script>
        <script
            id="MathJax-script"
            async
            src="https://cdn.jsdelivr.net/npm/mathjax@4/tex-mml-chtml.js"
        ></script>
        <script
            src="https://cdnjs.cloudflare.com/ajax/libs/viz.js/2.1.2/viz.js"
            integrity="sha512-vnRdmX8ZxbU+IhA2gLhZqXkX1neJISG10xy0iP0WauuClu3AIMknxyDjYHEpEhi8fTZPyOCWgqUCnEafDB/jVQ=="
            crossorigin="anonymous"
            referrerpolicy="no-referrer"
        ></script>
        <script
            src="https://cdnjs.cloudflare.com/ajax/libs/viz.js/2.1.2/full.render.js"
            integrity="sha512-1zKK2bG3QY2JaUPpfHZDUMe3dwBwFdCDwXQ01GrKSd+/l0hqPbF+aak66zYPUZtn+o2JYi1mjXAqy5mW04v3iA=="
            crossorigin="anonymous"
            referrerpolicy="no-referrer"
        ></script>
        <script>
         /*<![CDATA[<*/
         const viz = new Viz();
         
         Promise.all(Array.from(
             document.getElementsByClassName("graphviz")
         ).map(element => {
             viz.renderSVGElement(element.textContent).then(svg => {
                 element.replaceWith(svg);
             });
         }));
         /*]]*/
        </script>
    </body>
</html>
