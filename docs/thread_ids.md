As described elsewhere, for each thread, PROBE collects a log of operations that happen in that thread. Some operations, like `pthread_create` and `pthread_join`, interact with other threads. For those interthread operations, we want to know _which_ other thread is getting created or joined. Therefore, we need a thread ID.

Pthread does not really provide us with IDs. The handle, `pthread_t` is opaque and needs to be compared with `pthread_equals`. Therefore, it would be incorrect to use the bits of `pthread_t` as an ID, and impossible to make a fast hashtable from `pthread_t` to an integer.

We could use `gettid()`, but how would we map a call to `pthread_create/join` with a `pthread_t` to the Linux TID of the created/joined thread? There can't be a portable way to do that because, the mapping between Pthreads and hardware threads (aka 1:1, N:1, M:N) is left up to the implementation, but I would settle for a Linux-specific way of doing that.

Instead, we rely on our existing interpositioning. In PROBE's `pthread_create`, we atomically increments a counter to retrieve a unique ID and pass that ID to the created thread in the `void*` arg. We also replace the thread's run-function with a function that parses the arg void-pointer, finds the original (pre-interposition) `void*` arg and run-function. PROBE's replacement run-function returns a struct containing the original run-function's return value and the thread ID. PROBE's `pthread_join` calls the underlying `pthread_join` to get the return value, recovers the thread ID and passes along the original function's return value.
