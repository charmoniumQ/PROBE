#![allow(non_upper_case_globals)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(unsafe_op_in_unsafe_fn)] // <- PyO3 breaks without this

use crate::error::{ProbeError, Result};
use crate::transcribe::ArenaContext;
use probe_macros::{MakePyDataclass, MakeRustOp};
use serde::{Deserialize, Serialize};
use std::ffi::CString;

/// Specialized version of [`std::convert::From`] for working with libprobe arena structs.
///
/// Since [`ffi`] structs from arena allocator files have intrinsically invalid pointers (because
/// they came from a different virtual memory space). This trait and It's sibling [`FfiInto`]
/// exist to act as [`From`] and [`Into`] with an added parameter of a [`ArenaContext`] that can be
/// used to decode pointers.
pub(crate) trait FfiFrom<T> {
    fn ffi_from(value: &T, ctx: &ArenaContext) -> Result<Self>
    where
        Self: Sized;
}

/// Specialized version of [`std::convert::Into`] for working with libprobe arena structs.
///
/// Much like [`std::convert::Into`] this trait is implemented automatically with a blanket
/// implementation as the reciprocal of [`FfiFrom`].
pub(crate) trait FfiInto<T> {
    fn ffi_into(&self, ctx: &ArenaContext) -> Result<T>;
}

impl<T, U> FfiInto<U> for T
where
    U: FfiFrom<T>,
{
    #[inline]
    fn ffi_into(&self, ctx: &ArenaContext) -> Result<U> {
        U::ffi_from(self, ctx)
    }
}

// these are the three base implementations of FFiFrom; each generated Op implements FFiFrom by
// calling ffi_into(ctx) on each of it's fields, each fields *must* be either:
// - Another generated struct
// - A Copy-able value
// - An i8 pointer, which maps to the C *char and are converted to CStrings
impl<T: Copy> FfiFrom<T> for T {
    #[inline]
    fn ffi_from(value: &T, _: &ArenaContext) -> Result<Self> {
        Ok(*value)
    }
}
impl FfiFrom<*const i8> for CString {
    #[inline]
    fn ffi_from(value: &*const i8, ctx: &ArenaContext) -> Result<Self> {
        try_cstring(*value, ctx)
    }
}
impl FfiFrom<*mut i8> for CString {
    #[inline]
    fn ffi_from(value: &*mut i8, ctx: &ArenaContext) -> Result<Self> {
        try_cstring(*value, ctx)
    }
}

fn try_cstring(str: *const i8, ctx: &ArenaContext) -> Result<CString> {
    if str.is_null() {
        std::ffi::CString::new("").map_err(|_| ProbeError::MissingNull)
    } else {
        match ctx.try_get_slice(str as usize) {
            Some(x) => Ok(std::ffi::CStr::from_bytes_until_nul(x)
                .map_err(|_| ProbeError::MissingNull)?
                .to_owned()),
            None => Err(ProbeError::InvalidPointer(str as usize)),
        }
    }
}

// Bindings are generated by `../build.sh` and the MakeRustOp proc-macro
include!(concat!(env!("OUT_DIR"), "/bindings.rs"));

// NOTE: the raw versions of these Ops are tagged unions, so currently they have to be manually
// implemented, this is somewhat confusing since they extensively use types and trait
// implementations that are auto-generated.

#[derive(Debug, Clone, Serialize, Deserialize, MakePyDataclass)]
pub enum Metadata {
    Mode {
        mode: mode_t,
    },
    Ownership {
        uid: uid_t,
        gid: gid_t,
    },
    Times {
        is_null: bool,
        atime: timeval,
        mtime: timeval,
    },
}

impl FfiFrom<Bindgen_UpdateMetadataOp> for Metadata {
    fn ffi_from(value: &Bindgen_UpdateMetadataOp, ctx: &ArenaContext) -> Result<Self> {
        let kind = value.kind;
        let value = value.value;

        log::debug!("[unsafe] decoding Metadata tagged union");
        Ok(match kind {
            Bindgen_MetadataKind_MetadataMode => Metadata::Mode {
                mode: unsafe { value.mode },
            },
            Bindgen_MetadataKind_MetadataOwnership => Metadata::Ownership {
                uid: unsafe { value.ownership }.uid,
                gid: unsafe { value.ownership }.gid,
            },
            Bindgen_MetadataKind_MetadataTimes => Metadata::Times {
                is_null: unsafe { value.times }.is_null,
                atime: unsafe { value.times }.atime.ffi_into(ctx)?,
                mtime: unsafe { value.times }.mtime.ffi_into(ctx)?,
            },
            _ => return Err(ProbeError::InvalidVariant(kind)),
        })
    }
}

#[derive(Debug, Clone, Serialize, Deserialize, MakePyDataclass)]
pub struct UpdateMetadataOp {
    pub path: Path,
    pub flags: ::std::os::raw::c_int,
    pub metadata: Metadata,
    pub ferrno: ::std::os::raw::c_int,
}

impl FfiFrom<Bindgen_UpdateMetadataOp> for UpdateMetadataOp {
    fn ffi_from(value: &Bindgen_UpdateMetadataOp, ctx: &ArenaContext) -> Result<Self> {
        Ok(Self {
            path: value.path.ffi_into(ctx)?,
            flags: value.flags,
            metadata: value
                .ffi_into(ctx)
                .map_err(|e| ProbeError::FFiConversionError {
                    msg: "Unable to decode Metadata",
                    inner: Box::new(e),
                })?,
            ferrno: value.ferrno,
        })
    }
}

#[derive(Debug, Clone, Serialize, Deserialize, MakePyDataclass)]
pub enum OpInternal {
    InitProcessOp(InitProcessOp),
    InitExecEpochOp(InitExecEpochOp),
    InitThreadOp(InitThreadOp),
    OpenOp(OpenOp),
    CloseOp(CloseOp),
    ChdirOp(ChdirOp),
    ExecOp(ExecOp),
    CloneOp(CloneOp),
    ExitOp(ExitOp),
    AccessOp(AccessOp),
    StatOp(StatOp),
    ReaddirOp(ReaddirOp),
    WaitOp(WaitOp),
    GetRUsageOp(GetRUsageOp),
    UpdateMetadataOp(UpdateMetadataOp),
    ReadLinkOp(ReadLinkOp),
}

impl FfiFrom<Bindgen_Op> for OpInternal {
    fn ffi_from(value: &Bindgen_Op, ctx: &ArenaContext) -> Result<Self> {
        let kind = value.op_code;
        let value = value.data;

        log::debug!("[unsafe] decoding Op tagged union [ OpCode={} ]", kind);
        Ok(match kind {
            Bindgen_OpCode_init_process_op_code => {
                Self::InitProcessOp(unsafe { value.init_process_epoch }.ffi_into(ctx)?)
            }
            Bindgen_OpCode_init_exec_epoch_op_code => {
                Self::InitExecEpochOp(unsafe { value.init_exec_epoch }.ffi_into(ctx)?)
            }
            Bindgen_OpCode_init_thread_op_code => {
                Self::InitThreadOp(unsafe { value.init_thread }.ffi_into(ctx)?)
            }
            Bindgen_OpCode_open_op_code => Self::OpenOp(unsafe { value.open }.ffi_into(ctx)?),
            Bindgen_OpCode_close_op_code => Self::CloseOp(unsafe { value.close }.ffi_into(ctx)?),
            Bindgen_OpCode_chdir_op_code => Self::ChdirOp(unsafe { value.chdir }.ffi_into(ctx)?),
            Bindgen_OpCode_exec_op_code => Self::ExecOp(unsafe { value.exec }.ffi_into(ctx)?),
            Bindgen_OpCode_clone_op_code => Self::CloneOp(unsafe { value.clone }.ffi_into(ctx)?),
            Bindgen_OpCode_exit_op_code => Self::ExitOp(unsafe { value.exit }.ffi_into(ctx)?),
            Bindgen_OpCode_access_op_code => Self::AccessOp(unsafe { value.access }.ffi_into(ctx)?),
            Bindgen_OpCode_stat_op_code => Self::StatOp(unsafe { value.stat }.ffi_into(ctx)?),
            Bindgen_OpCode_readdir_op_code => {
                Self::ReaddirOp(unsafe { value.readdir }.ffi_into(ctx)?)
            }
            Bindgen_OpCode_wait_op_code => Self::WaitOp(unsafe { value.wait }.ffi_into(ctx)?),
            Bindgen_OpCode_getrusage_op_code => {
                Self::GetRUsageOp(unsafe { value.getrusage }.ffi_into(ctx)?)
            }
            Bindgen_OpCode_update_metadata_op_code => {
                Self::UpdateMetadataOp(unsafe { value.update_metadata }.ffi_into(ctx)?)
            }
            Bindgen_OpCode_read_link_op_code => {
                Self::ReadLinkOp(unsafe { value.read_link }.ffi_into(ctx)?)
            }
            _ => return Err(ProbeError::InvalidVariant(kind)),
        })
    }
}

#[derive(Debug, Clone, Serialize, Deserialize, MakePyDataclass)]
pub struct Op {
    pub data: OpInternal,
    pub time: timespec,
}

impl FfiFrom<Bindgen_Op> for Op {
    fn ffi_from(value: &Bindgen_Op, ctx: &ArenaContext) -> Result<Self> {
        Ok(Self {
            data: value.ffi_into(ctx)?,
            time: value.time.ffi_into(ctx)?,
        })
    }
}
