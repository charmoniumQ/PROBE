#![allow(non_upper_case_globals)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]

use crate::transcribe::ArenaContext;
use color_eyre::eyre::{Result, WrapErr, eyre};
use probe_macros::MakeRustOp;
use pyo3::pyclass;
use serde::{Deserialize, Serialize};

/// Specialized version of [`std::convert::From`] for working with libprobe arena structs.
///
/// Since [`ffi`] structs from arena allocator files have intrinsically invalid pointers (because
/// they came from a different virtual memory space). This trait and It's sibling [`FfiInto`]
/// exist to act as [`From`] and [`Into`] with an added parameter of a [`ArenaContext`] that can be
/// used to decode pointers.
pub(crate) trait FfiFrom<T> {
    fn ffi_from(value: &T, ctx: &ArenaContext) -> Result<Self>
    where
        Self: Sized;
}

/// Specialized version of [`std::convert::Into`] for working with libprobe arena structs.
///
/// Much like [`std::convert::Into`] this trait is implemented automatically with a blanket
/// implementation as the reciprocal of [`FfiFrom`].
pub(crate) trait FfiInto<T> {
    fn ffi_into(&self, ctx: &ArenaContext) -> Result<T>;
}

impl<T: Copy> FfiFrom<T> for T {
    fn ffi_from(value: &T, _ctx: &ArenaContext) -> Result<Self> {
        Ok(*value)
    }
}

impl<T, U> FfiInto<U> for T
where
    U: FfiFrom<T>,
{
    #[inline]
    fn ffi_into(&self, ctx: &ArenaContext) -> Result<U> {
        U::ffi_from(self, ctx)
    }
}

impl FfiFrom<*const i8> for std::ffi::CString {
    fn ffi_from(value: &*const i8, ctx: &ArenaContext) -> Result<Self> {
        let str = *value; 
        if str.is_null() {
            std::ffi::CString::new("").wrap_err("Failed to create empty CString")
        } else {
            match ctx.try_get_slice(str as usize) {
                Some(x) => Ok(std::ffi::CStr::from_bytes_until_nul(x)
                    .wrap_err("Failed to create CString")?
                    .to_owned()),
                None => Err(eyre!("Unable to lookup pointer {0:#x}", (str as usize))),
            }
        }
    }
}

impl FfiFrom<*mut i8> for std::ffi::CString {
    fn ffi_from(value: &*mut i8, ctx: &ArenaContext) -> Result<Self> {
        let str = *value; 
        if str.is_null() {
            std::ffi::CString::new("").wrap_err("Failed to create empty CString")
        } else {
            match ctx.try_get_slice(str as usize) {
                Some(x) => Ok(std::ffi::CStr::from_bytes_until_nul(x)
                    .wrap_err("Failed to create CString")?
                    .to_owned()),
                None => Err(eyre!("Unable to lookup pointer {0:#x}", (str as usize))),
            }
        }
    }
}

// Bindings are generated by `../build.sh` and the MakeRustOp proc-macro
include!(concat!(env!("OUT_DIR"), "/bindings.rs"));


// NOTE: the raw versions of these Ops are tagged unions, so currently they have to be manually
// implemented, this is somewhat confusing since they extensively use types and trait
// implementations that are auto-generated.

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum OpInternal {
    InitProcess(InitProcessOp),
    InitExecEpoch(InitExecEpochOp),
    InitThread(InitThreadOp),
    Open(OpenOp),
    Close(CloseOp),
    Chdir(ChdirOp),
    Exec(ExecOp),
    Clone(CloneOp),
    Exit(ExitOp),
    Access(AccessOp),
    Stat(StatOp),
    Readdir(ReaddirOp),
    Wait(WaitOp),
    GetRUsage(GetRUsageOp),
    UpdateMetadata(UpdateMetadataOp),
    ReadLink(ReadLinkOp),
}

impl FfiFrom<Bindgen_Op> for OpInternal {
    fn ffi_from(value: &Bindgen_Op, ctx: &ArenaContext) -> Result<Self> {
        let kind = value.op_code;
        let value = value.data;

        log::debug!("[unsafe] decoding Op tagged union [ OpCode={} ]", kind);
        Ok(match kind {
            Bindgen_OpCode_init_process_op_code => {
                Self::InitProcess(unsafe { value.init_process_epoch }.ffi_into(ctx)?)
            }
            Bindgen_OpCode_init_exec_epoch_op_code => Self::InitExecEpoch(
                unsafe { value.init_exec_epoch }
                    .ffi_into(ctx)
                    .wrap_err("Unable to decode InitExecEpochOp")?,
            ),
            Bindgen_OpCode_init_thread_op_code => Self::InitThread(unsafe { value.init_thread }.ffi_into(ctx)?),
            Bindgen_OpCode_open_op_code => Self::Open(
                unsafe { value.open }
                    .ffi_into(ctx)
                    .wrap_err("Unable to decode OpenOp")?,
            ),
            Bindgen_OpCode_close_op_code => Self::Close(unsafe { value.close }.ffi_into(ctx)?),
            Bindgen_OpCode_chdir_op_code => Self::Chdir(
                unsafe { value.chdir }
                    .ffi_into(ctx)
                    .wrap_err("Unable to decode ChdirOp")?,
            ),
            Bindgen_OpCode_exec_op_code => Self::Exec(
                unsafe { value.exec }
                    .ffi_into(ctx)
                    .wrap_err("Unable to decode ExecOp")?,
            ),
            Bindgen_OpCode_clone_op_code => Self::Clone(unsafe { value.clone }.ffi_into(ctx)?),
            Bindgen_OpCode_exit_op_code => Self::Exit(unsafe { value.exit }.ffi_into(ctx)?),
            Bindgen_OpCode_access_op_code => Self::Access(
                unsafe { value.access }
                    .ffi_into(ctx)
                    .wrap_err("Unable to decode AccessOp")?,
            ),
            Bindgen_OpCode_stat_op_code => Self::Stat(
                unsafe { value.stat }
                    .ffi_into(ctx)
                    .wrap_err("Unable to decode StatOp")?,
            ),
            Bindgen_OpCode_readdir_op_code => Self::Readdir(
                unsafe { value.readdir }
                    .ffi_into(ctx)
                    .wrap_err("Unable to decode ReaddirOp")?,
            ),
            Bindgen_OpCode_wait_op_code => Self::Wait(unsafe { value.wait }.ffi_into(ctx)?),
            Bindgen_OpCode_getrusage_op_code => Self::GetRUsage(unsafe { value.getrusage }.ffi_into(ctx)?),
            Bindgen_OpCode_update_metadata_op_code => Self::UpdateMetadata(
                unsafe { value.update_metadata }
                    .ffi_into(ctx)
                    .wrap_err("Unable to decode UpdateMetadataOp")?,
            ),
            Bindgen_OpCode_read_link_op_code => Self::ReadLink(
                unsafe { value.read_link }
                    .ffi_into(ctx)
                    .wrap_err("Unable to decode ReadlinkOp")?,
            ),
            _ => {
                if kind < Bindgen_OpCode_LAST_OP_CODE && kind > Bindgen_OpCode_FIRST_OP_CODE {
                    return Err(eyre!(
                        "Valid OpCode not handled (this is a bug, please report it)"
                    ));
                } else {
                    return Err(eyre!("Invalid OpCode"));
                }
            }
        })
    }
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Op {
    pub data: OpInternal,
    pub time: timespec,
}

impl FfiFrom<Bindgen_Op> for Op {
    fn ffi_from(value: &Bindgen_Op, ctx: &ArenaContext) -> Result<Self> {
        Ok(Self {
            data: value
                .ffi_into(ctx)
                .wrap_err("Unable to decode OpInternal")?,
            time: value.time.ffi_into(ctx)?,
        })
    }
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum Metadata {
    Mode(mode_t),
    Ownership {
        uid: uid_t,
        gid: gid_t,
    },
    Times {
        is_null: bool,
        atime: timeval,
        mtime: timeval,
    },
}

impl FfiFrom<Bindgen_UpdateMetadataOp> for Metadata {
    fn ffi_from(value: &Bindgen_UpdateMetadataOp, ctx: &ArenaContext) -> Result<Self> {
        let kind = value.kind;
        let value = value.value;

        log::debug!("[unsafe] decoding Metadata tagged union");
        Ok(match kind {
            Bindgen_MetadataKind_MetadataMode => Metadata::Mode(unsafe { value.mode }),
            Bindgen_MetadataKind_MetadataOwnership => Metadata::Ownership {
                uid: unsafe { value.ownership }.uid,
                gid: unsafe { value.ownership }.gid,
            },
            Bindgen_MetadataKind_MetadataTimes => Metadata::Times {
                is_null: unsafe { value.times }.is_null,
                atime: unsafe { value.times }.atime.ffi_into(ctx)?,
                mtime: unsafe { value.times }.mtime.ffi_into(ctx)?,
            },
            _ => return Err(eyre!("Invalid MetadataKind Variant")),
        })
    }
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UpdateMetadataOp {
    pub path: Path,
    pub flags: ::std::os::raw::c_int,
    pub metadata: Metadata,
    pub ferrno: ::std::os::raw::c_int,
}

impl FfiFrom<Bindgen_UpdateMetadataOp> for UpdateMetadataOp {
    fn ffi_from(value: &Bindgen_UpdateMetadataOp, ctx: &ArenaContext) -> Result<Self> {
        Ok(Self {
            path: value.path.ffi_into(ctx)?,
            flags: value.flags,
            metadata: value.ffi_into(ctx).wrap_err("Unable to decode Metadata")?,
            ferrno: value.ferrno,
        })
    }
}
