<<<<<<< HEAD
<<<<<<< HEAD
use parking_lot::RwLock;
use quote::quote_spanned;
use std::fmt::Display;
use std::fs::File;
use std::io::Write;
use std::sync::OnceLock;
use syn::{spanned::Spanned, Data, Fields};

use crate::MacroResult;

fn pygen_file() -> &'static RwLock<PygenFile> {
    static INNER: OnceLock<RwLock<PygenFile>> = OnceLock::new();
    INNER.get_or_init(|| RwLock::new(PygenFile::new()))
}

pub fn pygen_dataclass_internal(input: syn::DeriveInput) -> MacroResult<()> {
=======
=======
use std::collections::HashSet;
>>>>>>> f7c22ab (:sparkles: documentation :sparkles:)
use std::fmt::Display;
use std::fs::File;
use std::io::Write;
use std::sync::{OnceLock, RwLock};
use syn::{Data, Fields};

// hashset of previously generated dataclass, this is used during type conversion to ensure that
// every type in a dataclass is an already generated (or is a primitive type).
static GENERATED_TYPES: OnceLock<RwLock<HashSet<String>>> = OnceLock::new();

/// statically defined python code that gets added to the begining of the outputed file
const PYGEN_PREAMBLE: &str = "
# This file is automatically @generated by probe_macros

import sys
import typing
from dataclasses import dataclass

mod = sys.modules[__name__]

";

pub fn make_py_dataclass_internal(input: syn::DeriveInput) {
>>>>>>> a83cce7 (version 0.2.0)
    let syn::DeriveInput { data, ident, .. } = input.clone();
    let ident = pascal_to_snake_case(&ident.to_string());

    match data {
        Data::Struct(data_struct) => {
            let fields = match data_struct.fields {
                Fields::Named(x) => x,
<<<<<<< HEAD
                _ => {
                    return Err(quote_spanned! {
                        input.span() =>
                        compile_error!("Unnamed and unit structs not implemented")
                    }
                    .into())
                }
=======
                _ => unimplemented!("unnamed and unit structs not implemented"),
>>>>>>> a83cce7 (version 0.2.0)
            };

            let pairs = fields
                .named
                .iter()
<<<<<<< HEAD
<<<<<<< HEAD
                .filter_map(|field| {
                    if let syn::Type::Tuple(syn::TypeTuple { elems, .. }) = &field.ty {
                        // this is the unit type, so we just skip it
                        if elems.is_empty() {
                            return None;
                        }
                    }

                    let pair =
                        convert_to_pytype(&field.ty).and_then(|ty| match field.ident.as_ref() {
                            Some(ident) => Ok((ident.to_string(), ty)),
                            None => Err(quote_spanned! {
                                field.span() =>
                                compile_error!("Field doesn't have identifier");
                            }
                            .into()),
                        });

                    Some(pair)
                })
                .collect::<MacroResult<Vec<(_, _)>>>()?;

            let dataclass = basic_dataclass(ident.to_string(), &pairs);
            pygen_file().write().classes.push(dataclass);
        }
        Data::Enum(data_enum) => {
            let mut enu = Enum::new(ident.to_string());
=======
                .map(|x| {
                    let ident = x.ident.as_ref().unwrap();
                    (ident.to_string(), convert_to_pytype(&x.ty))
=======
                .map(|field| {
                    (
                        field.ident.as_ref().unwrap().to_string(),
                        convert_to_pytype(&field.ty),
                    )
>>>>>>> 7d0fa6a (code review improvements)
                })
                .collect::<Vec<(_, _)>>();

            write_dataclass(basic_dataclass(ident, &pairs));
        }
        Data::Enum(data_enum) => {
            // let mut dataclass = format!("@dataclass(init=False)\nclass {}:\n", ident);
            let mut dataclass = Dataclass::new(ident);
            let mut init = DataclassInit::new();
            let mut args = InitArgs::new();
>>>>>>> a83cce7 (version 0.2.0)

            // this is the types that the produced union is over
            let mut variants = vec![];

            for variant in data_enum.variants {
                match variant.fields {
                    syn::Fields::Named(inner) => {
                        let name = pascal_to_snake_case(&variant.ident.to_string());

                        let pairs = inner
                            .named
                            .iter()
<<<<<<< HEAD
<<<<<<< HEAD
                            .filter_map(|field| {
                                // skip any field who's type is the unit type
                                if let syn::Type::Tuple(syn::TypeTuple { elems, .. }) = &field.ty {
                                    if elems.is_empty() {
                                        return None;
                                    }
                                }

                                let pair = convert_to_pytype(&field.ty).and_then(|ty| match field
                                    .ident
                                    .as_ref()
                                {
                                    Some(ident) => Ok((ident.to_string(), ty)),
                                    None => Err(quote_spanned! {
                                        field.span() =>
                                        compile_error!("Field doesn't have identifier");
                                    }
                                    .into()),
                                });

                                Some(pair)
                            })
                            .collect::<MacroResult<Vec<_>>>()?;

                        enu.add_variant_owned_class(basic_dataclass(name.clone(), &pairs));
=======
                            .map(|x| {
                                let name = x.ident.as_ref().unwrap();
                                (name.to_string(), convert_to_pytype(&x.ty))
=======
                            .map(|field| {
                                (
                                    pascal_to_snake_case(&field.ident.as_ref().unwrap().to_string()),
                                    convert_to_pytype(&field.ty),
                                )
>>>>>>> 7d0fa6a (code review improvements)
                            })
                            .collect::<Vec<_>>();

                        dataclass.add_inclass(basic_dataclass(name.clone(), &pairs));
>>>>>>> a83cce7 (version 0.2.0)
                        variants.push(name);
                    }
                    syn::Fields::Unnamed(inner) => {
                        let fields = inner.unnamed.iter().collect::<Vec<_>>();
                        if fields.len() != 1 {
<<<<<<< HEAD
                            return Err(quote_spanned! {
                                inner.span() =>
                                compile_error!("Tuple enums of length != 1 not supported")
                            }
                            .into());
                        }
                        enu.add_variant_ref(convert_to_pytype(&fields[0].ty)?);
                    }
                    syn::Fields::Unit => {
                        return Err(quote_spanned! {
                            variant.fields.span() =>
                            compile_error!("Unit enum variants not supported")
                        }
                        .into())
                    }
                }
            }

            pygen_file().write().enums.push(enu);
        }
        Data::Union(_data_union) => {
            return Err(quote_spanned! {
                input.span() =>
                compile_error!("Unions not supported")
            }
            .into())
        }
    };

    Ok(())
}

fn basic_dataclass(name: String, pairs: &[(String, String)]) -> Dataclass {
    let mut dataclass = Dataclass::new(name);

    for (ident, ty) in pairs {
        dataclass.add_item(DataclassItem::new(ident.clone(), ty.clone()));
    }

    dataclass
}

fn convert_to_pytype(ty: &syn::Type) -> MacroResult<String> {
    match ty {
        syn::Type::Array(inner) => Ok(format!("list[{}]", convert_to_pytype(inner.elem.as_ref())?)),
        syn::Type::Path(inner) => {
            let name = crate::type_basename(inner)?.to_string();
            Ok(match name.as_str() {
                // that's a lot of ways to say "int", python ints are bigints so we don't have to
                // care about size
                "TaskType" | "__dev_t" | "__gid_t" | "__ino_t" | "__mode_t" | "__s32" | "__s64"
                | "__suseconds_t" | "__syscall_slong_t" | "__syseconds_t" | "__time_t"
                | "__u16" | "__u32" | "__u64" | "__uid_t" | "c_int" | "c_long" | "c_uint"
                | "c_ulong" | "dev_t" | "gid_t" | "i128" | "i16" | "i32" | "i64" | "i8"
                | "ino_t" | "isize" | "mode_t" | "pid_t" | "pthread_t" | "thrd_t" | "u128"
                | "u16" | "u32" | "u64" | "u8" | "uid_t" | "usize" => "int".to_owned(),

                // float, python uses doubles for everything
                "f32" | "f64" => "float".to_owned(),

                // CStrings are serialized as an array of bytes, so it makes sense to load them
                // into python as bytes
                "CString" => "bytes".to_owned(),

                // bool types are basically the same everywhere
                "bool" => name,

                _ => name,
            })
        }
        _ => Err(quote_spanned! {
            ty.span() =>
            compile_error!("Unsupported type type");
        }
        .into()),
    }
}

pub(crate) fn pygen_write_internal(path: syn::LitStr) -> MacroResult<()> {
    let path_str = path.value();
    let path_str = match std::env::var_os(path_str) {
        Some(x) => x,
        None => {
            return Err(quote_spanned! {
                path.span() =>
                compile_error!("Environmnet variable not defined");
            }
            .into())
        }
    };

    let mut file = match File::create(path_str) {
        Ok(x) => x,
        Err(e) => {
            eprintln!("pygen IO error: {}", e);
            return Err(quote_spanned! {
                path.span() =>
                compile_error!("Failed to create pygen file");
            }
            .into());
        }
    };

    pygen_file().write().prepend_preamble(
        [
            "from __future__ import annotations",
            "import typing",
            "from dataclasses import dataclass\n",
        ]
        .into_iter()
        .map(|x| x.to_owned())
        .collect(),
    );

    if let Err(e) = writeln!(file, "{}", pygen_file().read()) {
        eprintln!("pygen IO error: {}", e);
        return Err(quote_spanned! {
            path.span() =>
            compile_error!("Failed to write pygen file");
        }
        .into());
    }

    Ok(())
}

pub(crate) fn pygen_add_prop_internal(args: crate::AddPropArgs) -> MacroResult<()> {
    let class = args.class.to_string();
    let mut prop = DataclassProp::new(args.name.to_string(), args.ret.to_string());
    args.body.into_iter().for_each(|x| prop.body.push(x));

    let mut write_lock = pygen_file().write();

    let dataclass = match write_lock
        .classes
        .iter_mut()
        .find(|dataclass| dataclass.name == class)
    {
        Some(x) => x,
        None => {
            return Err(quote_spanned! {
                args.class.span() =>
                compile_error!("No such dataclass found");
            }
            .into())
        }
    };

    dataclass.add_prop(prop);

    Ok(())
}

pub(crate) fn pygen_add_preamble(args: crate::AddPreambleArgs) {
    pygen_file().write().append_preamble(args.0)
}

#[derive(Debug, Clone)]
struct PygenFile {
    preamble: Vec<String>,
    pub classes: Vec<Dataclass>,
    pub enums: Vec<Enum>,
}

#[derive(Debug, Clone)]
struct Enum {
    indent: usize,
    pub name: String,
    variants_owned_class: Vec<Dataclass>,
    variants_owned_enum: Vec<Enum>,
    variants_ref: Vec<String>,
}

#[derive(Debug, Clone)]
struct Dataclass {
    indent: usize,
    pub name: String,
    inclasses: Vec<Dataclass>,
    items: Vec<DataclassItem>,
    properties: Vec<DataclassProp>,
}

#[derive(Debug, Clone)]
struct DataclassItem {
    indent: usize,
    name: String,
    ty: String,
}

#[derive(Debug, Clone)]
struct DataclassProp {
    indent: usize,
    name: String,
    ret: String,
    pub body: Vec<String>,
}

#[allow(dead_code)]
impl PygenFile {
    pub fn new() -> Self {
        Self {
            preamble: vec![],
            classes: vec![],
            enums: vec![],
        }
    }

    pub fn prepend_preamble(&mut self, mut lines: Vec<String>) {
        lines.extend(std::mem::take(&mut self.preamble));
        self.preamble = lines;
    }

    pub fn append_preamble(&mut self, lines: Vec<String>) {
        self.preamble.extend(lines);
    }
}

#[allow(dead_code)]
impl Enum {
    pub fn new(name: String) -> Self {
        Self {
            indent: 0,
            name,
            variants_owned_class: vec![],
            variants_owned_enum: vec![],
            variants_ref: vec![],
        }
    }

    pub fn add_variant_owned_class(&mut self, mut item: Dataclass) {
        item.set_indent(self.indent);
        self.variants_owned_class.push(item);
    }

    pub fn add_variant_owned_enum(&mut self, mut item: Enum) {
        item.set_indent(self.indent);
        self.variants_owned_enum.push(item);
    }

    pub fn add_variant_ref(&mut self, item: String) {
        self.variants_ref.push(item);
    }

    pub fn set_indent(&mut self, indent: usize) {
        for class in &mut self.variants_owned_class {
            class.set_indent(indent);
        }
        for enu in &mut self.variants_owned_enum {
            enu.set_indent(indent);
        }

        self.indent = indent;
    }
}

#[allow(dead_code)]
=======
                            unimplemented!("Tuple enums of length != 1 not supported")
                        }
                        variants.push(convert_to_pytype(&fields[0].ty));
                    }
                    syn::Fields::Unit => unimplemented!("Unit enum variants not supported"),
                }
            }

            // here we merge the variants together in a python union
            let union_type = format!(
                "typing.Union[{}]",
                variants
                    .iter()
                    .fold(String::new(), |mut acc, x| {
                        acc.push_str(x);
                        acc.push_str(", ");

                        acc
                    })
                    .strip_suffix(", ")
                    .expect("union had no variants")
            );
            dataclass.add_item(DataclassItem::new("value".to_owned(), union_type));

            args.add(
                "**kwargs".to_owned(),
                "typing.Mapping[str, typing.Any]".to_owned(),
            );
            // add custom init that does some quasi-quoting hackery
            [
                "if len(kwargs) != 1:",
                "    raise ValueError(\"Malformed Enum constructor args\")",
                "key = list(kwargs.keys())[0]",
                "if key in self.__class__.__dict__:",
                "    self.value = self.__class__.__dict__[key](**kwargs[key])",
                "else:",
                "    self.value = mod.__dict__[key](**kwargs[key])",
            ]
            .into_iter()
            .for_each(|line| init.add_line(line.to_owned()));

            init.set_args(args);
            dataclass.set_init(Some(init));
            write_dataclass(dataclass);
        }
        Data::Union(_data_union) => unimplemented!(),
    };
}

fn basic_dataclass(name: String, pairs: &[(String, String)]) -> Dataclass {
    // this function take a type and identifier that's part of the argumetns to the init fucnction
    // and creates the expression for converting it for sotrage in the dataclass, basically this
    // means running primitive types through their type constructor to validate them and for other
    // dataclasses the arg get unpacked and passed to the relevant class constructor.
    fn make_conversion(ident: &str, ty: &str) -> String {
        match ty {
            // don't unpack primitive types
            "bytes" | "int" | "str" | "bool" => format!("{}({})", ty, ident),
            _ => format!("{}(**{})", ty, ident),
        }
    }

    let mut dataclass = Dataclass::new(name);
    let mut init = DataclassInit::new();
    let mut args = InitArgs::new();

    for (ident, ty) in pairs {
        dataclass.add_item(DataclassItem::new(ident.clone(), ty.clone()));
        init.add_line(format!("self.{} = {}", ident, make_conversion(ident, ty)));
        args.add(ident.clone(), ty.clone());
    }

    init.set_args(args);
    dataclass.set_init(Some(init));

    dataclass
}

fn convert_to_pytype(ty: &syn::Type) -> String {
    match ty {
        syn::Type::Array(inner) => {
            format!("list[{}]", convert_to_pytype(inner.elem.as_ref()))
        }
        syn::Type::Path(inner) => {
            let name = crate::type_basename(inner).to_string();
            match name.as_str() {
                // that's a lot of ways to say "int", python ints are bigints so we don't have to
                // care about size
                "__dev_t" | "__gid_t" | "__ino_t" | "__mode_t" | "__s32" | "__s64"
                | "__suseconds_t" | "__syscall_slong_t" | "__syseconds_t" | "__time_t"
                | "__u16" | "__u32" | "__u64" | "__uid_t" | "c_int" | "c_long" | "c_uint"
                | "dev_t" | "gid_t" | "i32" | "ino_t" | "mode_t" | "pid_t" | "uid_t" => {
                    "int".to_owned()
                }

                // CStrings are serialized as an array of bytes, so it makes sense to load them
                // into python as bytes
                "CString" => "bytes".to_owned(),

                // bool types are basically the same everywhere
                "bool" => name,

                // other types are checked to see if it's a dataclass we've already written, if it
                // is we can simply pass it through unchanged, otherwise we don't know how to
                // convert this type and we panic.
                //
                // FIXME: this approach works fine for generation when running `cargo build` but
                // rust-analyzer indicates that the proc-macro paniced; they're probably being
                // processed in a compartmentalized manner in rust-analyzer.
                _ => {
                    let snake_case = pascal_to_snake_case(&name);

                    let types = GENERATED_TYPES
                        .get_or_init(|| RwLock::new(HashSet::new()))
                        .read()
                        .expect("python generated types rwlock poisioned");

                    if types.contains(&snake_case) {
                        snake_case
                    } else {
                        panic!("Can't convert type '{}' to a python type", snake_case);
                    }
                }
            }
        }
        _ => unimplemented!("unsupported type type"),
    }
}

fn pascal_to_snake_case(ident: &str) -> String {
    // this primitive lookback is needed so that names with repeated capitals like SocketTCP get
    // turned into socket_tcp and not socket_t_c_p
    let mut prior_upper = true;
    ident
        .chars()
        .fold(String::new(), |mut acc, ch| {
            if ch.is_uppercase() {
                if !prior_upper {
                    acc.push('_')
                }
                ch.to_lowercase().for_each(|lower_ch| acc.push(lower_ch));
                prior_upper = true;
            } else {
                acc.push(ch);
                prior_upper = false;
            }
            acc
        })
}

fn write_dataclass(item: Dataclass) {
    static DATACLASSES: OnceLock<RwLock<File>> = OnceLock::new();
    let mut writer = DATACLASSES
        .get_or_init(|| {
            let mut file = File::create(concat!(env!("CARGO_MANIFEST_DIR"), "/../python/ops.py"))
                .expect("unable to create ops.py");
            file.write_all(PYGEN_PREAMBLE.as_bytes())
                .expect("failed to write preamble");
            RwLock::new(file)
        })
        .write()
        .expect("python dataclasses rwlock poisioned");
    writeln!(writer, "{}", item).expect("failed to write pygen");

    GENERATED_TYPES
        .get_or_init(|| RwLock::new(HashSet::new()))
        .write()
        .expect("python generated types rwlock poisioned")
        .insert(item.name);
}

struct Dataclass {
    indent: usize,
    pub name: String,
    inclasses: Vec<Dataclass>,
    items: Vec<DataclassItem>,
    init: Option<DataclassInit>,
}

>>>>>>> a83cce7 (version 0.2.0)
impl Dataclass {
    pub fn new(name: String) -> Self {
        Self {
            indent: 0,
            name,
            inclasses: vec![],
            items: vec![],
<<<<<<< HEAD
            properties: vec![],
=======
            init: None,
>>>>>>> a83cce7 (version 0.2.0)
        }
    }

    pub fn add_inclass(&mut self, mut inclass: Dataclass) {
        inclass.set_indent(self.indent + 4);
        self.inclasses.push(inclass)
    }

    pub fn add_item(&mut self, mut item: DataclassItem) {
        item.set_indent(self.indent + 4);
        self.items.push(item)
    }

<<<<<<< HEAD
    pub fn add_prop(&mut self, mut prop: DataclassProp) {
        prop.set_indent(self.indent + 4);
        self.properties.push(prop)
    }

    pub fn set_indent(&mut self, indent: usize) {
=======
    pub fn set_init(&mut self, init: Option<DataclassInit>) {
        self.init = init.map(|mut x| {
            x.set_indent(self.indent + 4);
            x
        });
    }

    pub fn set_indent(&mut self, mut indent: usize) -> usize {
>>>>>>> a83cce7 (version 0.2.0)
        for inclass in &mut self.inclasses {
            inclass.set_indent(indent + 4);
        }
        for item in &mut self.items {
            item.set_indent(indent + 4);
        }
<<<<<<< HEAD

        self.indent = indent;
    }
}

=======
        if let Some(init) = &mut self.init {
            init.set_indent(indent + 4);
        }

        std::mem::swap(&mut self.indent, &mut indent);
        indent
    }
}

impl Display for Dataclass {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let name = self.name.as_str();
        let indent_str = " ".repeat(self.indent);
        let gen_init = match self.init {
            Some(_) => "False",
            None => "True",
        };

        // write class signature
        writeln!(
            f,
            "{indent_str}@dataclass(init={gen_init})\n\
            {indent_str}class {name}:"
        )?;

        // write inner class definitions
        for inclass in &self.inclasses {
            writeln!(f, "{inclass}",)?;
        }

        // write dataclass fields
        for item in &self.items {
            writeln!(f, "{item}")?;
        }

        // write init definition (if any)
        if let Some(init) = &self.init {
            write!(f, "{init}")?;
        }

        Ok(())
    }
}

struct DataclassItem {
    indent: usize,
    name: String,
    ty: String,
}

>>>>>>> a83cce7 (version 0.2.0)
impl DataclassItem {
    pub fn new(name: String, ty: String) -> Self {
        Self {
            indent: 0,
            name,
            ty,
        }
    }

<<<<<<< HEAD
    pub fn set_indent(&mut self, indent: usize) {
        self.indent = indent;
    }
}

impl DataclassProp {
    pub fn new(name: String, ret: String) -> Self {
        Self {
            indent: 0,
            name,
            ret,
            body: vec![],
        }
    }

    pub fn set_indent(&mut self, indent: usize) {
        self.indent = indent;
    }
}

// Display trait implementations for actual codegen

impl Display for PygenFile {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        writeln!(f, "# This file was @generated by probe_macros")?;

        for line in self.preamble.iter() {
            writeln!(f, "{line}")?;
        }
        writeln!(f)?;

        for class in self.classes.iter() {
            writeln!(f, "{class}")?;
        }

        for enu in self.enums.iter() {
            writeln!(f, "{enu}")?;
        }

        Ok(())
    }
}

impl Display for Enum {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        fn print_union_type(types: &[&str], f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            if types.is_empty() {
                write!(f, "None")?;
                return Ok(());
            }
            let mut iter = types.iter();

            // unwrap allowed because we checked that types isn't empty
            let first = iter.next().unwrap();
            write!(f, "{first}")?;

            for ty in iter {
                write!(f, " | {ty}")?;
            }

            Ok(())
        }

        let name = &self.name;
        let mut acc = Vec::new();

        for owned_variant in self.variants_owned_class.iter() {
            writeln!(f, "{owned_variant}")?;
            acc.push(owned_variant.name.as_str());
        }

        for owned_variant in self.variants_owned_enum.iter() {
            writeln!(f, "{owned_variant}")?;
            acc.push(owned_variant.name.as_str());
        }

        self.variants_ref.iter().for_each(|x| acc.push(x));

        let indent_str = " ".repeat(self.indent);
        write!(f, "{indent_str}{name}: typing.TypeAlias = ")?;
        print_union_type(acc.as_slice(), f)
    }
}

impl Display for Dataclass {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let name = self.name.as_str();
        let indent_str = " ".repeat(self.indent);

        writeln!(
            f,
            "{indent_str}@dataclass(init=True, frozen=True)\n\
            {indent_str}class {name}:"
        )?;

        for inclass in &self.inclasses {
            writeln!(f, "{inclass}",)?;
        }

        for item in &self.items {
            writeln!(f, "{item}")?;
        }
        writeln!(f)?;

        for prop in &self.properties {
            writeln!(f, "{prop}")?;
        }

        Ok(())
=======
    pub fn set_indent(&mut self, mut indent: usize) -> usize {
        std::mem::swap(&mut self.indent, &mut indent);
        indent
>>>>>>> a83cce7 (version 0.2.0)
    }
}

impl Display for DataclassItem {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let &Self { name, ty, .. } = &self;
        let indent_str = " ".repeat(self.indent);
        write!(f, "{indent_str}{name}: {ty}")
    }
}

<<<<<<< HEAD
impl Display for DataclassProp {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let &Self { name, ret, .. } = &self;
        let indent_str = " ".repeat(self.indent);

        writeln!(
            f,
            "{indent_str}@property\n\
            {indent_str}def {name}(self) -> {ret}:",
        )?;
=======
struct DataclassInit {
    indent: usize,
    args: InitArgs,
    body: Vec<String>,
}

impl DataclassInit {
    pub fn new() -> Self {
        Self {
            indent: 0,
            args: InitArgs::new(),
            body: vec![],
        }
    }

    pub fn add_line(&mut self, line: String) {
        self.body.push(line)
    }

    pub fn set_args(&mut self, args: InitArgs) {
        self.args = args;
    }

    pub fn set_indent(&mut self, mut indent: usize) -> usize {
        std::mem::swap(&mut self.indent, &mut indent);
        indent
    }
}

impl Display for DataclassInit {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let &Self { args, .. } = &self;
        let indent_str = " ".repeat(self.indent);

        writeln!(f, "{indent_str}def __init__(self{args}):")?;
>>>>>>> a83cce7 (version 0.2.0)

        for line in &self.body {
            writeln!(f, "{indent_str}    {line}")?;
        }

        Ok(())
    }
}
<<<<<<< HEAD
=======

struct InitArgs {
    pairs: Vec<(String, String)>,
}

impl InitArgs {
    pub fn new() -> Self {
        Self { pairs: vec![] }
    }

    pub fn add(&mut self, name: String, ty: String) {
        self.pairs.push((name, ty))
    }
}

impl Display for InitArgs {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        for arg in &self.pairs {
            let (name, ty) = arg;
            write!(f, ", {name}: {ty}")?;
        }
        Ok(())
    }
}
>>>>>>> a83cce7 (version 0.2.0)
