import abc
import collections
import typing

from . import drawing as drawing

_Node = typing.TypeVar("_Node", bound=typing.Hashable)
_dict: typing.TypeAlias = dict[str, typing.Any]

class Graph(typing.Generic[_Node]):
    def __init__(
            self,
            incoming_graph_data: collections.abc.Iterable[tuple[_Node, _Node]] = frozenset(),
    ) -> None:
        ...

    def add_node(self, node: _Node, **kwargs: typing.Any) -> None: ...
    def add_nodes_from(self, nodes: typing.Iterable[_Node], **kwargs: typing.Any) -> None: ...
    def remove_node(self, node: _Node) -> None: ...
    def has_node(self, node: _Node) -> bool: ...

    def add_edge(self, src: _Node, dst: _Node, **kwargs: typing.Any) -> None: ...
    def add_edges_from(self, edges: typing.Iterable[tuple[_Node, _Node]], **kwargs: typing.Any) -> None: ...
    def remove_edge(self, src: _Node, dst: _Node) -> None: ...
    def has_edge(self, src: _Node, dst: _Node) -> bool: ...

    def __len__(self) -> int: ...

    # graph.get_edge_data(a, b) is better than graph.edges[a, b] because graph.edges is already overloaded.
    def get_edge_data(self, src: _Node, dst: _Node) -> dict[str, typing.Any]: ...

    @typing.overload
    def nodes(self) -> NodeView[_Node]: ...

    @typing.overload
    def nodes(self, data: typing.Literal[False]) -> NodeView[_Node]: ...

    @typing.overload
    def nodes(self, data: typing.Literal[True]) -> NodeDataView[_Node]: ...

    @typing.overload
    def edges(self) -> EdgeView[tuple[_Node, _Node]]: ...

    @typing.overload
    def edges(self, data: typing.Literal[False]) -> EdgeDataView[tuple[_Node, _Node]]: ...

    @typing.overload
    def edges(self, data: typing.Literal[True]) -> typing.Iterable[tuple[_Node, _Node, _dict]]: ...

    def copy(self, as_view: bool = ...) -> DiGraph[_Node]: ...


class DiGraph(Graph[_Node]):
    def successors(self, node: _Node) -> typing.Iterable[_Node]: ...
    def predecessors(self, node: _Node) -> typing.Iterable[_Node]: ...
    def in_degree(self, node: _Node) -> int: ...
    def out_degree(self, node: _Node) -> int: ...
    def reverse(self) -> DiGraph[_Node]: ...


class NodeView(typing.Iterable[_Node], typing.Generic[_Node], metaclass=abc.ABCMeta): ...


class NodeDataView(typing.Generic[_Node], metaclass=abc.ABCMeta):
    def __iter__(self) -> typing.Iterator[tuple[_Node, _dict]]: ...
    def __getitem__(self, node: _Node) -> _dict: ...


class EdgeView(typing.Iterable[tuple[_Node, _Node]], typing.Generic[_Node], metaclass=abc.ABCMeta): ...


class EdgeDataView(typing.Generic[_Node], metaclass=abc.ABCMeta):
    def __iter__(self) -> typing.Iterator[tuple[_Node, _Node, _dict]]: ...
    def __getitem__(self, node: tuple[_Node, _Node]) -> _dict: ...


def bfs_edges(graph: Graph[_Node], source: _Node, reverse: bool = ...) -> typing.Iterator[list[_Node]]: ...

def bfs_layers(graph: Graph[_Node], source: _Node = ...) -> typing.Iterator[list[_Node]]: ...

def dfs_edges(graph: Graph[_Node], source: _Node = ...) -> typing.Iterator[tuple[_Node, _Node]]: ...

def dfs_preorder_nodes(graph: Graph[_Node], source: _Node = ...) -> typing.Iterator[_Node]: ...

def dfs_postorder_nodes(graph: Graph[_Node], source: _Node = ...) -> typing.Iterator[_Node]: ...

def bfs_successors(graph: Graph[_Node], source: _Node) -> typing.Iterator[_Node]: ...

def bfs_predecessors(graph: Graph[_Node], source: _Node) -> typing.Iterator[_Node]: ...

def topological_sort(digraph: DiGraph[_Node]) -> typing.Iterator[_Node]: ...

def topological_generations(digraph: DiGraph[_Node]) -> typing.Iterator[set[_Node]]: ...

def find_cycle(digraph: DiGraph[_Node]) -> typing.Iterator[tuple[_Node, _Node]]: ...

def is_directed_acyclic_graph(graph: Graph[_Node]) -> bool: ...

def is_weakly_connected(graph: Graph[_Node]) -> bool: ...

def is_planar(graph: Graph[_Node]) -> bool: ...

def weakly_connected_components(graph: Graph[_Node]) -> typing.Iterator[frozenset[_Node]]: ...

def descendants(graph: Graph[_Node], source: _Node) -> typing.Iterable[_Node]: ...


_Node2 = typing.TypeVar("_Node2")
def relabel_nodes(digraph: DiGraph[_Node], mapping: typing.Mapping[_Node, _Node2], copy: bool = ...) -> DiGraph[_Node2]: ...

class NetworkXNoCycle(Exception): ...


def transitive_closure(
        digraph: DiGraph[_Node],
        reflexive: bool = ...,
) -> DiGraph[_Node]: ...


def transitive_reduction(
        digraph: DiGraph[_Node],
) -> DiGraph[_Node]: ...


def quotient_graph(
        digraph: DiGraph[_Node],
        partition: typing.Callable[[_Node, _Node], bool],
) -> DiGraph[frozenset[_Node]]: ...


def check_planarity(
        graph: Graph[_Node],
) -> tuple[typing.Literal[True], PlanarEmbedding[_Node]] | tuple[typing.Literal[False], None]:
    ...

class PlanarEmbedding(Graph[_Node]):
    def traverse_face(self, a: _Node, b: _Node) -> list[_Node]:
        ...
