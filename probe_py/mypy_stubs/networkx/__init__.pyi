from . import drawing as drawing

import typing

_Node = typing.TypeVar("_Node", bound=typing.Hashable)
_dict: typing.TypeAlias = dict[str, typing.Any]

class DiGraph(typing.Generic[_Node]):
    def add_node(self, node: _Node, **kwargs: typing.Any) -> None: ...
    def add_nodes_from(self, nodes: typing.Iterable[_Node], **kwargs: typing.Any) -> None: ...
    def remove_node(self, node: _Node) -> None: ...
    def has_node(self, node: _Node) -> bool: ...

    def add_edge(self, src: _Node, dst: _Node, **kwargs: typing.Any) -> None: ...
    def add_edges_from(self, edges: typing.Iterable[tuple[_Node, _Node]], **kwargs: typing.Any) -> None: ...
    def remove_edge(self, src: _Node, dst: _Node) -> None: ...
    def has_edge(self, src: _Node, dst: _Node) -> bool: ...

    def successors(self, node: _Node) -> typing.Iterable[_Node]: ...
    def predecessors(self, node: _Node) -> typing.Iterable[_Node]: ...

    def in_degree(self, node: _Node) -> int: ...
    def out_degree(self, node: _Node) -> int: ...

    def reverse(self) -> DiGraph[_Node]: ...

    # graph.get_edge_data(a, b) is better than graph.edges[a, b] because graph.edges is already overloaded.
    def get_edge_data(self, src: _Node, dst: _Node) -> dict[str, typing.Any]: ...

    @typing.overload
    def nodes(self) -> typing.Iterable[_Node]: ...

    @typing.overload
    def nodes(self, data: typing.Literal[False]) -> typing.Iterable[_Node]: ...

    @typing.overload
    def nodes(self, data: typing.Literal[True]) -> typing.Iterable[tuple[_Node, _dict]]: ...

    @typing.overload
    def edges(self) -> typing.Iterable[tuple[_Node, _Node]]: ...

    @typing.overload
    def edges(self, data: typing.Literal[False]) -> typing.Iterable[tuple[_Node, _Node]]: ...

    @typing.overload
    def edges(self, data: typing.Literal[True]) -> typing.Iterable[tuple[_Node, _Node, _dict]]: ...

    def copy(self, as_view: bool = ...) -> DiGraph[_Node]: ...


def bfs_layers(digraph: DiGraph[_Node], source: _Node = ...) -> typing.Iterator[list[_Node]]: ...


def dfs_edges(digraph: DiGraph[_Node], source: _Node = ...) -> typing.Iterator[tuple[_Node, _Node]]: ...


def dfs_preorder_nodes(digraph: DiGraph[_Node], source: _Node = ...) -> typing.Iterator[_Node]: ...


def dfs_postorder_nodes(digraph: DiGraph[_Node], source: _Node = ...) -> typing.Iterator[_Node]: ...


def bfs_successors(digraph: DiGraph[_Node], source: _Node) -> typing.Iterator[_Node]: ...


def bfs_predecessors(digraph: DiGraph[_Node], source: _Node) -> typing.Iterator[_Node]: ...


def topological_sort(digraph: DiGraph[_Node]) -> typing.Iterator[_Node]: ...


def find_cycle(digraph: DiGraph[_Node]) -> typing.Iterator[tuple[_Node, _Node]]: ...


def is_directed_acyclic_graph(digraph: DiGraph[_Node]) -> bool: ...


def is_weakly_connected(digraph: DiGraph[_Node]) -> bool: ...


def weakly_connected_components(digraph: DiGraph[_Node]) -> typing.Iterator[frozenset[_Node]]: ...


def descendants(digraph: DiGraph[_Node], source: _Node) -> typing.Iterable[_Node]: ...


class NetworkXNoCycle(Exception): ...


def transitive_closure(
        digraph: DiGraph[_Node],
        reflexive: bool = ...,
) -> DiGraph[_Node]: ...


def transitive_reduction(
        digraph: DiGraph[_Node],
) -> DiGraph[_Node]: ...
